---
title: The Nesting Instinct
tags: Haskell, beginner-friendly
withtoc: yes
---

### Intro

This post is an experiment I decided to attempt after conversations with Ben Lesh and some other folks. Often there are Haskell tutorials presented that attempt to explain an abstraction, for which they contrive some code that involves several other concepts that may be new or difficult to follow for the new Haskeller or the curious non-Haskeller. Instead I just want to show a common pattern that may already be familiar to such readers and then talk a little about how we talk about that pattern in Haskell.

I will assume as little knowledge of Haskell as I possibly can to demonstrate the pattern. In that way, I hope to make the gist of the thing accessible to as many people as possible, and I'd love to hear from you if you think there are things I could add or clarify in order to do so.

> A consequence of the focus on taxonomies in 17th and 18th century was the creation of museums, which present the studied objects neatly organized according to the taxonomy. A computer scientist of such alternative way of thinking might follow similar methods. Rather than finding mathematical abstractions and presenting abstract mathematical structures, she would build (online and interactive?) museums to present typical specimen as they appear in interesting situations in the real-world. -- Tomas Petricek, [Thinking the Unthinkable](http://tomasp.net/blog/2016/thinking-unthinkable/)


# A Few Notes about Haskell

I'm going to hand-wave away very large things about Haskell here in order to focus on the things that matter. Many readers can probably happily skip this section, as I will annotate the code below

The first thing important thing about Haskell is that all data in Haskell is (statically) typed. Types can be constructed out of other types. There are a few ways of doing this, but the way that will concern us here is by applying a type constructor to a type argument -- the same way a function would get applied to an argument and then evaluated. So, we have a type, called `Maybe` that looks like this:

```haskell
data Maybe a = Nothing | Just a
```

This datatype says that a value of type `Maybe a` is constructed by applying `Maybe` to another type; `a` is a variable so it could be almost any other type that we apply it to. We could have a `Maybe Integer` or a `Maybe String`, for example. It says that we have *either* a `Nothing` value, in the case where there was no `a` that we could construct a `Maybe a` value from, *or* (this is an exclusive disjunction, or sum type) a `Just a` value, where the `a` has to be the same type as the `a` of `Maybe a`. That is, if we're making a `Maybe String` value then we can either return a `Nothing` (where there is no `String` -- a kind of null or error value) or a `Just <String>`. We use this type very often in cases where we want to validate something and the possibility of not having a value to return from some computation exists -- a `String` might appear, on which we can perform some future computation, or it might not (`Nothing`).

Functions have type signatures in Haskell; they should be written down (I will be sternly prescriptive about this), but they may also be inferred by the GHC compiler's rather powerful type inference system. We can tell a lot of things about a function from reading its type signature, and I will annotate the signatures in the code that follows.


# Let's Validate some User Input!

For the purposes of our example, let's say we have a need to validate some passwords, surely the most exciting programming task we can imagine for ourselves today. We'll start by picking some dimensions along which we will validate passwords that our users have input.

We're going to use what we call `case` expressions here. I personally find the syntax slightly awkward but they are common in Haskell and, in my experience, many people who already know other programming languages find them fairly readable, so it's what I'll be using here.





# That Nesting Instinct



# Got a Sequential Series of Computations where each new one depends on the successful result of the one before it? Hey, use >>=!

# >>= is monadic

An algebra is a set together with some operation(s) that can be defined over that set. In this case, `>>=` is the symbol for an operation that can be defined over many (not all) sets (or types). This operation acts like a pipeline to allow us to compose other computations directly, rather than having to nest them as we did with the `case` expressions.

Sometimes Haskellers use the word *monad* to refer to this operation; often they use it to refer to the type, such as `Maybe`, that constitutes the set in this algebra.

Reasoning algebraically about code.



# Why do Haskellers care so much about this?

I'm not going to go too much into typeclasses here, how they work and how we leverage them to good effect in Haskell. So what else can we say about this? That by recognizing a common pattern and giving it a name, we can gain some intuition about other times we might see it and what to expect when we use them. In particular, Haskelllers like the opportunity to reason algebraically about things -- reasoning about code in terms of sets (types) and operations we can define over those sets without having to think too much about the persnickety details of each and every set that we could ever make. Can this type that we have here be used in sequential computations where the performance of the next computation depends in some way on the result of the one before it? Cool, you might have a monad then and recognizing that might give you some extra power to reason about and understand and predict what your code will do.


# A Note on Terminology

*Monad* can refer to a few things. One is a typeclass that (mostly) corresponds to an algebraic structure (a set plus some law-abiding operations defined for that set) of the same name; to form a complete algebra, in Haskell at least, though, you need three things:

- the typeclass declaration, which defines the operation *in maximal generality*;
- a type that can implement that operation; and
- a typeclass instance that binds the type with the typeclass declaration and defines the operation(s) specifically for that type.

Where I personally get tripped up is that, very often, Haskellers use the word "monad" to refer *to a type that implements the monad typeclass*. They do this with the names of other typeclasses, too, so the type `Maybe` *is* a monoid, a functor, a monad, and so on, because it is a type (set) that has [monoidal, functorial, monadic] operations defined over it.

# A Note on Learning Haskell

One of the reasons I hesitated so long to publish this post is that people who don't have much interest in learning Haskell or who are just at the beginning of learning Haskell seem, contrary to the [best advice on the internet](http://dev.stephendiehl.com/hask/#eightfold-path-to-monad-satori), to always want to know straightaway what a monad is. It's like they've taken on some outsized mythical status. But the monad is really a sort of small thing. It's a common enough programming task, chaining together sequences of functions that we want to behave in a predictable manner. Monad is a means of simplifying that (in some way; it doesn't seem like a simplification when it's new to you, but by giving us certain intuitions about how this pattern should behave -- the infamous monad laws! -- and being highly composable, they do remove some complexity, as the right abstraction should).

Everything we do in Haskell, even `IO`, can be done without monads, but not as easily or well. Monads are a small thing that let us do those things more easily, more regularly. I know when I was learning Haskell I had built it up in my mind that it would be this huge, difficult to understand thing, and it's sort of anticlimactic when you find out what it really is: instead of nesting case expressions or something like that, we'll just chain stuff together with an operator. Cool.

# Further reading:

- [A Gentle Intro to Monads ... Maybe?](http://sean.voisen.org/blog/2013/10/intro-monads-maybe/) -- code in this one is all JavaScript.
- [A Guide to FP Lingo for JavaScripters](https://gist.github.com/ericelliott/ea925c58410f0ae74aef) -- what the heck, it's like the JavaScripters outnumber us Haskellers. :)
- [It's a bit like asking "What is a number?"](https://stackoverflow.com/questions/44965/what-is-a-monad#10245311)
- [Adjacency](https://chris-martin.org/2015/adjacency) -- There is an interesting point being made here about adjacency in Haskell vs adjacency in `do`-blocks, but he rather undersells the fact that monadic binding (and, thus, `do` syntax, isn't just for `IO`.)



