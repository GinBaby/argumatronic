---
title: The Nesting Instinct
tags: Haskell, beginner-friendly
withtoc: yes
---

### Intro

This post is an experiment I decided to attempt after conversations with Ben Lesh and some other folks. I will assume as little knowledge of Haskell as I possibly can in presenting some a common pattern, a standard sort of program. Later we'll talk about some tools we have in Haskell to make the pattern more conceptually compact.

I hope to make the gist of the thing accessible to as many people as possible, and I'd love to hear from you if you think there are things I could add or clarify in order to do so.

> A consequence of the focus on taxonomies in 17th and 18th century was the creation of museums, which present the studied objects neatly organized according to the taxonomy. A computer scientist of such alternative way of thinking might follow similar methods. Rather than finding mathematical abstractions and presenting abstract mathematical structures, she would build (online and interactive?) museums to present typical specimen as they appear in interesting situations in the real-world. -- Tomas Petricek, [Thinking the Unthinkable](http://tomasp.net/blog/2016/thinking-unthinkable/)


# Notes about Haskell

If you can already read Haskell at least a little, go ahead and skip this section. I will annotate the code in the examples, but if you've never read Haskell at all, then this section may be helpful to you.

All data in Haskell is (statically) typed. Types may be concrete, such as `Integer` or `Bool`, but there are also *type constructors*. We construct a value of one of these types by applying the type constructor to a type argument -- the same way a function would get applied to an argument and then evaluated. So, we have a type, called `Maybe` that looks like this:

```haskell
data Maybe a = Nothing | Just a
```

This datatype says that a value of type `Maybe a` is constructed by applying `Maybe` to another type; `a` is a variable so it could be almost any other type that we apply it to. We could have a `Maybe Integer` or a `Maybe String`, for example. It says that we have *either* a `Nothing` value, in the case where there was no `a` that we could construct a `Maybe a` value from, *or* (this is an exclusive disjunction, known as a *sum type*) a `Just a` value, where the `a` has to be the same type as the `a` of `Maybe a`.

If we're constructing a `Maybe String` value then we can either return a `Nothing` (where there is no `String`) -- a kind of null or error value -- or a `Just <String>`. We use this type very often in cases where a possibility of not having a value to return from some computation exists -- a `String` might appear, on which we can perform some future computation, or it might not (`Nothing`).

Next let's look at `case` expressions, a common way of pattern matching on values to effect different outcomes based on the matched value. A `case` expression in general looks like this:

```haskell
function =
  case exp of
    value1 -> result1
    value2 -> result2
 -- ... (the pattern matches should be exhaustive, that is, cover all the possible values of that type)
```

The two values (or patterns) must be of the same type. When this function is called,`exp` will be evaluated, meaning it will be reduced to one of the values. That value is matched against `value1`, `value2`, and so on down. The first one it matches is chosen and the result of matching on that value is the result of the whole `case` expression. For example,

```haskell
function xs =
  case (xs == "Julie") of
    True -> (xs ++ " is 43.")
    False -> "How old are you?"
```

When this function is applied an argument that is equal to the `String` "Julie", it will match on the `True` (because `==` reduces to a `Bool`) and concatenate "Julie" with " is 43." Given any other `String` argument, it will match on the `False`.

> Note this doesn't include any means of printing any of our strings to the screen; if you want to play with it in the REPL, you can, as GHCi always runs an implicit `print` action. It's at the top of [the code file](code/passwords.hs) that goes with this post.

# Handling the cases

OK, let's say we need to validate some passwords. We'll start by picking some dimensions along which we will validate passwords that our users have input: let's say we'll first strip off any leading whitespace, we'll only allow alphanumeric characters (no special characters) and we'll have a maximum length of 15 characters because we want our customers to choose unsafe passwords.

We'll write each of our functions discretely at first so we can consider each problem separately. First, let's strip any leading whitespace off the input:

```haskell
stripSpacePwd :: String -> Maybe String
stripSpacePwd "" = Nothing
-- this first step gives us an "error" if the input is an empty string
-- and also provides a base case for the recursion in the case expression
stripSpacePwd (x:xs) =
  case (isSpace x) of
    True -> stripSpacePwd xs
    -- is recursive to strip off as many leading
    -- whitespaces as there are
    False -> Just (x:xs)
```

This `(x:xs)` construction is how we deconstruct lists (Strings, in this case) to pattern match on them element-by-element; the `x` refers to the head of the list and the `xs` to the rest of it. We test each `x` in the string to see if it is whitespace; if there is no leading whitespace, we return the entire string (wrapped in this `Just` constructor) -- the head, `x`, consed onto the rest of the list, `xs`. If there is whitespace, we return the tail of the list only (`xs`) and call the function again on the tail, in case there is more than one leading whitespace. If you give it a string of all whitespace, it'll hit that base case and return `Nothing` -- we have no password to validate. Otherwise it will stop when it reaches a character that isn't whitespace and take the `False` branch and return the password.

OK, next let's make sure we have only alphabetic characters. This one is a bit easier because we don't have to (manually) recurse, but otherwise the pattern is the same:

```haskell
checkAlpha :: String -> Maybe String
checkAlpha "" = Nothing
checkAlpha xs =
  case (all isAlpha xs) of
    False -> Nothing
    True -> Just xs
```

We're again returning a `Maybe String` so that we have the possibility of returning `Nothing`. (In a "real" program, that could allow us to match on the `Nothing` to return error statements to the user, for example. We'll see other was of handling this in later posts.) We used `isAlpha` which checks each character to see that it's an alphabetic character and `all` which recursively checks each item in a list for us and returns a `True` only when it's `True` for all the elements.

Finally, we'll add a length checker:

```haskell
validateLength :: String -> Maybe String
validateLength s =
  case (length s > 15) of
    True -> Nothing
    False -> Just s
```

We had decided on a maximum length of 15 characters, for purely evil reasons no doubt, so it takes the input string, checks to see if its length is longer than 15; if it is, we get a `Nothing` and if it's not, we get our password.

# Let's validate some passwords!

Now what we need to do is compose these somehow so that all of them are applied to the same input string and a failure at any juncture gives us an overall failure.

We could write one long function that nests all the various case expressions that we're using:

```haskell
makePasswd :: String -> Maybe String
makePasswd xs =
  case (null xs) of
  -- this is our initial check to see if it's an empty string; `null` returns a `Bool` value
    True -> Nothing
    False ->
      case (all isAlpha xs) of
        False -> Nothing
        True -> Just xs
        ...
```

But this is not only going to get quite long and hard to read and think about, it also doesn't allow us to easily reuse the functions to, say, validate a username later on.

We might initially be tempted to try just composing them in some way, perhaps:

```haskell
makePasswd :: String -> Maybe String
makePasswd xs = validateLength . checkAlpha . stripSpacePwd $ xs

makePasswd :: String -> Maybe String
makePasswd xs =  validateLength (checkAlpha (stripSpacePwd xs))
```

Unfortunately, both of those will throw slightly intimidating type errors!

The reason is that each of those functions returns a `Maybe String` -- not a `String` -- but they each only accept `String` as their first argument.

> At the risk of appearing quite not smart, I'll admit that when I was first learning Haskell, I used to sometimes write this all out on paper to trace the flow of the types through the nested or composed function applications.

What we need is something that will allow to chain together functions that take a `String` and return a `Maybe String`.

# In a bind

Conveniently, Haskell has an operator that does this: `>>=`. It's so important and beloved by Haskellers, that it's part of the Haskell logo! It's called bind, and we can chain our validation functions together with it like this:

```haskell
makePassword :: String -> Maybe String
makePassword xs = stripSpacePwd xs
                  >>= checkAlpha
                  >>= validateLength
```

The result of `stripSpacePwd` will affect the whole rest of the computation. If it's a `Nothing`, nothing else will get evaluated. If it's a `Just String`, then this particular operator allows us to pass that `Just String` to the next function, even though it needs a `String` as the first argument, like magic.

# Look at the types

> If you've never looked at Haskell before, this part might be opaque for you, but explaining all this in detail requires explaining almost all of Haskell.

Let's look at how `>>=` works. The (not quite complete) type signature for this operator looks like this:

```haskell
(>>=) :: m a -> (a -> m b) -> m b
--         ^     ^
--          these
--       are the same
```

When the `m` type constructor that we're talking about is `Maybe`, the type looks like this:

```haskell
(>>=) @Maybe :: Maybe a -> (a -> Maybe b) -> Maybe b
-- you can do this in your REPL by turning on the
-- language extension TypeApplications
```

The complete type of `>>=` looks like this:

```haskell
(>>=) :: Monad m => m a -> (a -> m b) -> m b
--       |________|
--       this part
-- tells us that whatever type `m` is, it has
-- to be a monad
```

Ahhh, the M word.

Our new friend `>>=` is the primary operation of the `Monad` typeclass, so very literally this constraint (`Monad m =>`) says that whatever type `m` is, it must be a type is a monad -- that is, that has an instance, or implementation, of this function `>>=` written for it.

### But what *is* a monad?

A monad is a type constructor (a type like `Maybe` that can take a type argument, not a concrete type like `Bool`) together with a (valid, lawful) implementation of the `>>=` operation. So you'll hear sentences like "`Maybe` is a monad" meaning it's a set that has such an implementation of `>>=`. And this is why you hear people talk about wrapping things "in a monad" or about containers and burritos and whatnot -- we even have a function that does nothing but wrap a value up so it can be used in such a computation.

> If you have a series of computations that should be performed sequentially such that each new one depends on the successful result of the one before it, you may want `>>=` to chain them together (which requires wrapping them in a [monad] type constructor such as `Maybe`.) `IO`, which is the obligatory type constructor of all `main` actions and all side-effecting code, is a monad, so a lot of code you'd write that will do anything involving `IO` is already wrapped in such a constructor and, hence, monadic.

# Algebras

An algebra is a set together with some operation(s) that can be defined over that set. In this case, `>>=` is the symbol for an operation that can be defined over many (not all) sets -- think of types as sets.

So, a monad is an algebra, or algebraic structure, that has at least two components:
- a set, or type, such as `Maybe`;
- a bind operation defined over it.

It also has some laws, or else it wouldn't be a proper algebra, and we talk a lot about the monad laws in Haskell and we can (and should) property check our `>>=` implementations to make sure they behave lawfully, but the Haskell compiler doesn't enforce them, so a monad in Haskell is maybe something slightly less imposing than a monad in mathematics.

### But isn't it a monoid in the category of endofunctors, though?

It is, and understanding why can be helpful. But it's not the right place to *start* understanding monads, unless you already understand some category theory, and while I admire such people, they are distinctly not my intended audience for this post. I suspect they would ostracize me for being so hand-wavy about all this.

Someday, I'll try to write a beginner friendly post about what it means that it's a monoid in the category of endofunctors. If you know what a monoid is and know that "endofunctors" for Haskell purposes just means "functors" and understand that by "functors" we mean type constructors (not, e.g., `fmap` itself), then perhaps the *monoidness* of `>>=` (and also the `Applicative` operation `<*>`) will begin to become apparent. Perhaps [Ken's Twitter thread](https://twitter.com/KenScambler/status/955441793465696257) will help, too. If you don't already understand those things, then it might not, and that's OK; it takes time to build up and internalize all the concepts.

If you're trying to learn Haskell and don't already know category theory, it is perfectly fine to just use `>>=` when you need it and not worry any more about it. Since all user input and every `main` action in Haskell is handled with *monads*, you sort of have to to be able to use them without understanding them deeply for a while.

### But what about `do` syntax?

I didn't use that, even though it is meant to allow the writing of monadic code in a nice imperative style, because I don't always like (for teaching purposes) the fact that it hides the somewhat composition-like piping of arguments between functions. I once said it ["hides the functors"](https://joyofhaskell.com/posts/2017-05-07-do-notation.html); it makes it harder for me to follow the flow of types through the function applications, and so I don't particularly like it when I'm teaching people about functors and monads. It's cool to start using `do` to effect monadic operations without understanding how `>>=` works, though; we've all been there.


# Why do Haskellers care so much about this?

I'm not going to go too much into typeclasses here, how they work and how we leverage them to good effect in Haskell. So what else can we say about this? That by recognizing a common pattern and giving it a name, we can gain some intuition about other times we might see it and what to expect when we use them.

In particular, Haskellers like the opportunity to reason algebraically about things -- reasoning about code in terms of sets (types) and operations we can define over those sets without having to think too much about the persnickety details of each and every set that we could ever make. Can this type that we have here be used in sequential computations where the performance of the next computation depends in some way on the result of the one before it? Cool, you might have a monad then and recognizing that might give you some extra power to reason about and understand and predict what your code will do.

# A Note on Terminology

*Monad* can refer to a few things. One is a typeclass that (mostly) corresponds to an algebraic structure (a set plus some law-abiding operations defined for that set) of the same name; to form a complete algebra, in Haskell at least, though, you need three things:

- the typeclass declaration, which defines the operation *with maximal generality*;
- a type that can implement that operation; and
- a typeclass instance that binds the type with the typeclass declaration and defines the operation(s) specifically for that type.

Usually, the phrase "X is a monad" tells you that X is a type constructor with an `instance` of `Monad`.

This is why I don't prefer saying that `Maybe` *is* an instance of `Monad` but, rather, that it *has* an instance because an `instance` declaration is a specific piece of code that has to exist or else the type has no legitimate implementation of the function. If no `instance` exists, no function exists for that set so we have an incomplete algebra.

Incidentally, Haskellers do this with the names of other typeclasses, too, so the type `Maybe` *is* a monoid, a functor, a monad, and so on, because it is a type (set) that has [monoidal, functorial, monadic] operations defined over it.

# A Note on Learning Haskell

One of the reasons I hesitated so long to publish this post is that people who don't have much interest in learning Haskell or who are just at the beginning of learning Haskell seem, contrary to the [best advice on the internet](http://dev.stephendiehl.com/hask/#eightfold-path-to-monad-satori), to always want to know straightaway what a monad is. It's like they've taken on some outsized mythical status. But the monad is really a sort of small thing. It's a common enough programming task, chaining together sequences of functions that we want to behave in a predictable manner. Monad is a means of simplifying that (in some way; it doesn't seem like a simplification when it's new to you, but by giving us certain intuitions about how this pattern should behave -- the infamous monad laws! -- and being highly composable, they do remove some complexity, as the right abstraction should).

Everything we do in Haskell, even `IO`, can be done without monads, but not as easily or well. Monads are a small thing that let us do those things more easily, more regularly. I know when I was learning Haskell I had built it up in my mind that it would be this huge, difficult to understand thing, and it's sort of anticlimactic when you find out what it really is: instead of nesting case expressions or something like that, we'll just chain stuff together with an operator. Cool.

# Further reading:

- [A Gentle Intro to Monads ... Maybe?](http://sean.voisen.org/blog/2013/10/intro-monads-maybe/) -- code in this one is all JavaScript.
- [A Guide to FP Lingo for JavaScripters](https://gist.github.com/ericelliott/ea925c58410f0ae74aef) -- what the heck, it's like the JavaScripters outnumber us Haskellers. :)
- [It's a bit like asking "What is a number?"](https://stackoverflow.com/questions/44965/what-is-a-monad#10245311)
- [Adjacency](https://chris-martin.org/2015/adjacency) -- There is an interesting point being made here about adjacency in Haskell vs adjacency in `do`-blocks, but he rather undersells the fact that monadic binding (and, thus, `do` syntax, isn't just for `IO`.)



