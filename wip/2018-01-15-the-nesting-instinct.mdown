---
title: The Nesting Instinct
tags: Haskell, beginner-friendly
withtoc: yes
---

### Intro

This post is an experiment I decided to attempt after conversations with Ben Lesh and some other folks. I will assume as little knowledge of Haskell as I possibly can in presenting some a common pattern, a standard sort of program. Later we'll talk about some tools we have in Haskell to make the pattern more conceptually compact.

I hope to make the gist of the thing accessible to as many people as possible, and I'd love to hear from you if you think there are things I could add or clarify in order to do so.

> A consequence of the focus on taxonomies in 17th and 18th century was the creation of museums, which present the studied objects neatly organized according to the taxonomy. A computer scientist of such alternative way of thinking might follow similar methods. Rather than finding mathematical abstractions and presenting abstract mathematical structures, she would build (online and interactive?) museums to present typical specimen as they appear in interesting situations in the real-world. -- Tomas Petricek, [Thinking the Unthinkable](http://tomasp.net/blog/2016/thinking-unthinkable/)


# Notes about Haskell

If you can already read Haskell at least a little, go ahead and skip this section. I will annotate the code in the examples, but if you've never read Haskell at all, then this section may be helpful to you.

All data in Haskell is (statically) typed. Types may be concrete, such as `Integer` or `Bool`, but there are also *type constructors*. We construct a value of one of these types by applying the type constructor to a type argument -- the same way a function would get applied to an argument and then evaluated. So, we have a type, called `Maybe` that looks like this:

```haskell
data Maybe a = Nothing | Just a
```

This datatype says that a value of type `Maybe a` is constructed by applying `Maybe` to another type; `a` is a variable so it could be almost any other type that we apply it to. We could have a `Maybe Integer` or a `Maybe String`, for example. It says that we have *either* a `Nothing` value, in the case where there was no `a` that we could construct a `Maybe a` value from, *or* (this is an exclusive disjunction, known as a *sum type*) a `Just a` value, where the `a` has to be the same type as the `a` of `Maybe a`.

If we're constructing a `Maybe String` value then we can either return a `Nothing` (where there is no `String`) -- a kind of null or error value -- or a `Just <String>`. We use this type very often in cases where a possibility of not having a value to return from some computation exists -- a `String` might appear, on which we can perform some future computation, or it might not (`Nothing`).

Next let's look at `case` expressions, a common way of pattern matching on values to effect different outcomes based on the matched value. A `case` expression in general looks like this:

```haskell
function =
  case exp where
    value1 -> result1
    value2 -> result2
 -- ... (the pattern matches should be exhaustive, that is, cover all the possible values of that type)
```

The two values (or patterns) must be of the same type. When this function is called, `exp` will be evaluated. Which result you


# Let's Validate some User Input!

For the purposes of our example, let's say we have a need to validate some passwords, surely the most exciting programming task we can imagine for ourselves today. We'll start by picking some dimensions along which we will validate passwords that our users have input.

We're going to use what we call `case` expressions here. I personally find the syntax slightly awkward but they are common in Haskell and, in my experience, many people who already know other programming languages find them fairly readable, so it's what I'll be using here.





# That Nesting Instinct



# Got a Sequential Series of Computations where each new one depends on the successful result of the one before it? Hey, use >>=!

# >>= is monadic

An algebra is a set together with some operation(s) that can be defined over that set. In this case, `>>=` is the symbol for an operation that can be defined over many (not all) sets (or types). This operation acts like a pipeline to allow us to compose other computations directly, rather than having to nest them as we did with the `case` expressions.

Sometimes Haskellers use the word *monad* to refer to this operation; often they use it to refer to the type, such as `Maybe`, that constitutes the set in this algebra.

Reasoning algebraically about code.



# Why do Haskellers care so much about this?

I'm not going to go too much into typeclasses here, how they work and how we leverage them to good effect in Haskell. So what else can we say about this? That by recognizing a common pattern and giving it a name, we can gain some intuition about other times we might see it and what to expect when we use them. In particular, Haskelllers like the opportunity to reason algebraically about things -- reasoning about code in terms of sets (types) and operations we can define over those sets without having to think too much about the persnickety details of each and every set that we could ever make. Can this type that we have here be used in sequential computations where the performance of the next computation depends in some way on the result of the one before it? Cool, you might have a monad then and recognizing that might give you some extra power to reason about and understand and predict what your code will do.


# A Note on Terminology

*Monad* can refer to a few things. One is a typeclass that (mostly) corresponds to an algebraic structure (a set plus some law-abiding operations defined for that set) of the same name; to form a complete algebra, in Haskell at least, though, you need three things:

- the typeclass declaration, which defines the operation *in maximal generality*;
- a type that can implement that operation; and
- a typeclass instance that binds the type with the typeclass declaration and defines the operation(s) specifically for that type.

Where I personally get tripped up is that, very often, Haskellers use the word "monad" to refer *to a type that implements the monad typeclass*. They do this with the names of other typeclasses, too, so the type `Maybe` *is* a monoid, a functor, a monad, and so on, because it is a type (set) that has [monoidal, functorial, monadic] operations defined over it.

# A Note on Learning Haskell

One of the reasons I hesitated so long to publish this post is that people who don't have much interest in learning Haskell or who are just at the beginning of learning Haskell seem, contrary to the [best advice on the internet](http://dev.stephendiehl.com/hask/#eightfold-path-to-monad-satori), to always want to know straightaway what a monad is. It's like they've taken on some outsized mythical status. But the monad is really a sort of small thing. It's a common enough programming task, chaining together sequences of functions that we want to behave in a predictable manner. Monad is a means of simplifying that (in some way; it doesn't seem like a simplification when it's new to you, but by giving us certain intuitions about how this pattern should behave -- the infamous monad laws! -- and being highly composable, they do remove some complexity, as the right abstraction should).

Everything we do in Haskell, even `IO`, can be done without monads, but not as easily or well. Monads are a small thing that let us do those things more easily, more regularly. I know when I was learning Haskell I had built it up in my mind that it would be this huge, difficult to understand thing, and it's sort of anticlimactic when you find out what it really is: instead of nesting case expressions or something like that, we'll just chain stuff together with an operator. Cool.

# Further reading:

- [A Gentle Intro to Monads ... Maybe?](http://sean.voisen.org/blog/2013/10/intro-monads-maybe/) -- code in this one is all JavaScript.
- [A Guide to FP Lingo for JavaScripters](https://gist.github.com/ericelliott/ea925c58410f0ae74aef) -- what the heck, it's like the JavaScripters outnumber us Haskellers. :)
- [It's a bit like asking "What is a number?"](https://stackoverflow.com/questions/44965/what-is-a-monad#10245311)
- [Adjacency](https://chris-martin.org/2015/adjacency) -- There is an interesting point being made here about adjacency in Haskell vs adjacency in `do`-blocks, but he rather undersells the fact that monadic binding (and, thus, `do` syntax, isn't just for `IO`.)



