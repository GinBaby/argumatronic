---
title: Indexing Haskell (book)
tags: Haskell, personal
---

As most people who will read this are aware, I've spent the past few weeks trying very hard to get my book, [Haskell Programming from First Principles](http://haskellbook.com/), finished up. There were errors to correct, LaTeX tags to standardize, proofreading to do, and an index to make. We, unfortunately, had not had the foresight to think about how it would be indexed from the beginning. We had sprinkled a few index tags about, but not many.

We did try, briefly, at automating the placement of index tags (LaTeX generates the index, but you still have to place the tags telling it to index something), but nothing was very satisfying. Too much, or too little. It was clear I'd have to do most of it by hand, and I planned to do that as I proofread the book. I'm reading it anyway, it should be simple to just put in index tags as necessary, right?

Doing that wasn't giving me a high-level view of the index as a whole. While I have always appreciated a great book index, to the extent that I often wish even fiction were indexed (remember that passage where...? how can I find that again?), I had not given much thought to how to make a great index happen.

I started by thinking about what makes bad ones. So many books have unhelpful indexes. In one of my favorite cookbooks, the recipes are mostly indexed by the name the authors gave them, so to look up how to make that soup, I have to remember whatever they called it, not just "zucchini soup," and unfortunately I never can (I used colored pencils to highlight my favorite recipes in the index, but I shouldn't have had to). Other books seem to point you to just any use of a given term, not necessarily the ones that contain something essential about it. For this book, I don't want to index *literally every* mention of the `Bool` or `Maybe` type, for example, only the important mentions.

### A Book's User Interface

Next I started to think about the index as part of the book's user interface. A book's UI doesn't only comprise the index, of course. The table of contents, perhaps along with a "how to use this book" section, is also part of the user interface, but it's the authors telling you how they want you to use the book. The index, on the other hand, is there to let the reader use the book how *they* want to use it.

How would someone who has read the whole book but wants to refer back to something use the index? How would a reader who has just picked it up and maybe only read a chapter or two use it? What kinds of information would people want to know about the book that the index could reveal even if they hadn't read any of it? Are there ways, even, that the Haskell book index could help the book serve as *documentation* for the language and community? This seems too ambitious..

Placing index tags as I went through the book proofreading did a pretty good job at getting important instances of important terms listed in the index -- although when I went back to earlier chapters after I'd finished the last chapters, I realized I hadn't been nearly thorough enough early on. Getting those cross-listed so they are accessible through various terms (e.g., "sectioning" is listed as both "sectioning" and under "infix operators, sectioning") was the next step. You do not want to force your readers to remember the name of the zucchini soup!

### Helpful lists, I hope

Because of the way the book is laid out, intended to be worked through mostly sequentially, we don't have a specific place where we cover all the GHCi commands, or all the Stack and Cabal stuff you need to know. That kind of information is sprinkled throughout the book, wherever it came up in the course of teaching Haskell. Making sure those were grouped into lists in the index was my next step.

![*partial list*](/images/ghci-com.jpg)

But why stop there?

We'd made a point to explain GHCi error messages at various points in the book. They can be intimidating and hard to interpret, but they also give useful feedback, so we want to help people see them as part of a dialogue with the compiler. It seemed appropriate, then, to index some of those. If you get an "actual type did not match expected type" message and don't know or can't remember which is which, that's indexed, and the index points at places where we explain what that message is telling you. Wondering why you get a "No instance for `Show`" when you apply a function to too few arguments -- that answer is now easy to find!

Next, I listed the language extensions. Again, coverage of those (not by any means all of the language extensions that exist) is sprinkled throughout the book, but any reader might be in a position where they want to see `TypeApplications` or `InstanceSigs` demonstrated, before they reach a point where we do that (I think we probably should encourage more Haskell learners to use those liberally) -- or maybe they've already started a project that needs `OverloadedStrings` as so many do and need a quick way to find explanations and examples of usage. Each language extension we cover is listed both under its own name as well as in the list of language extensions.

![*partial list*](/images/langexts.jpg)

It was in the course of doing this that I learned the difference between "pragma" and "language extension" so then I also made a list of the pragmas we give at least some coverage, too. Probably not as useful to know as the extensions, but it can't hurt, right? I, for one, had forgotten we talked about `INLINABLE`.

Next, some internet argument about the fact that *Haskell is made up of expressions and declarations* not *just functions* made me want to list the varieties of declaration. We do talk about what the difference is in the book but what if you just want to know what all constitutes a *declaration*? The [Haskell Report tells you](https://www.haskell.org/definition/haskell2010.pdf), of course, but we could offer help there, too. Of course, our list isn't as comprehensive as the Report's because, again, it only covers what we discussed in the book.

![*partial list*](/images/declarations.jpg)

For similar reasons, I decided to do the same thing with *keywords* -- what are the keywords in Haskell and what are they used for? Again, my list doesn't necessarily include all of them, only what we covered in the book.

At the last minute, I decided to use "library" as an index term. There are a few libraries we really delved into -- we used the testing libraries `QuickCheck`, `hspec`, and `checkers` a lot. The data structures chapter has solid introductions to `criterion`, `containers`, and `vector`. Those and `bytestring` and `text` might seem reasonably obvious to cover. But I think it's less obvious that we covered `scotty`, `network`, `random`, `trifecta`, `aeson`, and `sqlite-simple` -- at least three of those are used in complete projects, even. footnote We have a perhaps TMI investigation of `scotty`'s transformer stacks in the monad transformers chapter, but not a full web app built with it.

![*partial list*](/images/libraries.jpg)

So, now, when you're ready to start a project, no matter where you are in the book, and you want direct help using `random` or `wreq` or `time`, you can find it.

I am -- yes, I am very pleased with myself. I hope that the index will serve as a good entry point and reference to -- well, not just the book, but to Haskell, or GHC Haskell, at least the parts that seemed most relevant to going from unfamiliarity with the language to building projects with it. There are omissions, no doubt, and I'll work to correct some of those in future editions.
