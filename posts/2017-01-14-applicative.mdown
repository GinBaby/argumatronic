---
title: Applicative I: More Like a Hot Dog than a Burrito
tags: Haskell
---

> This is part one of a three-part post that recaps the workshop I gave at LambdaConf Winter Retreat, January 2017. This part will cover some differences between `Applicative` and `Monad` and some cool things about `Applicative`. The next part will discuss a datatype called `AccValidation` that does not have a `Monad` instance. The final part will demonstrate these two typeclasses, along with `Alternative`, specifically with regard to *parsing* and work through example code that uses the `optparse-applicative` library. I'm telling you this now so that you'll hold me to it. **Prerequisites**: This assumes some knowledge of Haskell syntax, particularly `case` expressions and datatypes such as `Maybe` and `Either.`

## Starting with Functor

Let's take a short look at `Functor` -- specifically, `fmap` -- to make sure we're all on the same page. `fmap` is a generalization of `map`: instead of only being able to map over lists, `fmap` allows us to map a function over many kinds of data structures. If you look at the type signature:

```haskell
fmap :: Functor f => (a -> b) -> f a -> f b
```
The `f`s are polymorphic but *constrained* by the `Functor` typeclass to be types that are instances of that typeclass.  So, sure, it works with lists:

```haskell
fmap (^2) [1, 2, 3]
[1,4,9]
```
But it works just as well with many other types:

```haskell
fmap (^2) (Just 8)
Just 64
```
The idea is that we want to apply a function to a value that is *inside* some structure (type) while leaving that structure intact. We call this lifting. The word "lifting," when used in Haskell at least, refers to applying a type constructor to a type. `fmap` is lifting because it applies the type constructor `f` to the types `a` and `b`. 

## A Monad Tutorial

Despite what you may have heard in the past about `Monad`, it's not much different from `Functor` -- in fact, it is a variety of functor. There is only a small (but important) difference between them. 

The `Monad` typeclass includes several operators, but the minimal complete definition of it only includes this operator, called `bind`:

```haskell
(>>=) :: Monad m => m a -> (a -> m b) -> m b
```
It might initially look quite different from `fmap` because the argument order is strangely flipped. Let's use the "flip bind" operator and compare it directly to `fmap`:

```haskell
(=<<) :: Monad m   => (a -> m b) -> m a -> m b

fmap  :: Functor f => (a -> b)   -> f a -> f b
```
I've added some extra spaces to make them line up better. The `m` variables are analogous to the `f` variables: they represent type constructors that are instances of `Monad` or `Functor`, respectively. Any type that is an instance of `Monad` must also be an instance of `Functor` but the reverse is not true. 

The difference between these two functors is that, in the monadic version, the function that is being applied is itself generating a layer of structure. We can concretize the types to make it a little more clear:

```haskell
λ> :set -XTypeApplications
λ> :t fmap @Maybe
fmap @Maybe :: (a -> b) -> Maybe a -> Maybe b
λ> :t (=<<) @Maybe
(=<<) @Maybe :: (a -> Maybe b) -> Maybe a -> Maybe b
```
With the monadic operators (`(>>=)` and `(=<<)`), you're still lifting a function into a context in order to apply it to the value inside, but now the function produces an `m b` instead of just a `b`. That means the result of the function application is a nested structure (e.g., `Maybe (Maybe b)`) and we have the special monadic function `join` that smooshes those two layers into one. You can write `(>>=)` for yourself by composing `fmap` with `join`. 

One important thing about monads, though, is they allow us to *sequence* actions and render the results of one dependent on earlier results. In a monadic context, returning a `Nothing` or empty list at any point can cause later computations to short-circuit. Let's take a look:

```haskell
data Person = Person {
      name   :: String
    , age    :: Int
    , pl     :: String
   } deriving (Eq, Show)

nonEmpty :: String -> Maybe String
nonEmpty ""  = Nothing
nonEmpty str = Just str

nonNegative :: Int -> Maybe Int
nonNegative n | n >= 0 = Just n
              | otherwise = Nothing

plCheck :: Person -> Maybe Person
plCheck c =
  let p = pl c
      n = name c
  in if n == "Simon" && (p /= "Haskell")
     then Nothing
     else Just c
```
Our `Person` datatype constructs a person record out of a name, an age, and a `String` that we want to represent the name of a programming language. Two functions, `nonEmpty` and `nonNegative` check to make sure we have valid inputs -- no empty strings or negative numbers. And `plCheck` checks to make sure that if given the name `String` "Simon" then the programming language is Haskell. If it's a Simon that doesn't use Haskell, I'm sorry, but it's not a valid person. 

So, let's put this together:

```haskell
mkPerson :: String
            -> Int
            -> String
            -> Maybe Person
mkPerson name' age' pl' =
  case nonEmpty name' of
   Nothing -> Nothing
   -- if name is empty, the whole thing will return Nothing
   -- if it's not empty, it returns Just name and goes on to
   -- the next check
   Just named ->
     case nonNegative age' of
      Nothing -> Nothing
      -- if a negative number, we get Nothing; otherwise, go on
      Just aged ->
        case nonEmpty pl' of
          Nothing -> Nothing
          -- and again check for empty strings
          Just lang ->
              plCheck (Person named aged lang)
```
We only apply `plCheck` if none of the cases above returned a `Nothing` value. If we get a `Nothing` at any point, the whole thing will return `Nothing`. You can also use `do` syntax for this, even though there is no `IO` involved (`do` syntax is for monads, and `Maybe` is our monad here). This is the same as the big nested `case` function above: 

```haskell
mkPerson' :: String -> Int -> String -> Maybe Person
mkPerson' name' age' pl' = do
  named <- nonEmpty name'
  aged <- nonNegative age'
  lang <- nonEmpty pl'
  plCheck (Person named aged lang)
```
And here are attempts to construct various `Person` values:

```haskell
-- successfully constructing a Simon
λ> mkPerson "Simon" 45 "Haskell"
Just (Person {name = "Simon", age = 45, pl = "Haskell"})

λ> mkPerson' "Simon" 45 "Haskell"
Just (Person {name = "Simon", age = 45, pl = "Haskell"})

-- failure at nonNegative
λ> mkPerson "Chris" (-1) "Scala"
Nothing

-- failure at nonEmpty
λ> mkPerson' "" 45 "Scala"
Nothing

-- successful until plCheck
λ> mkPerson "Simon" 45 "Scala"
Nothing
```
The `Nothing` result is somewhat less than helpful in terms of being able to figure out where we failed. We can rewrite our `main` to use the `Either` datatype to give us some information about where things go wrong:

```haskell
plCheck :: Person -> Either String Person
plCheck c =
  let p = pl c
      n = name c
  in if n == "Simon" && (p /= "Haskell")
     then Left "All Simons write Haskell."
     else Right c

mkPerson :: String
            -> Int
            -> String
            -> Either String Person
mkPerson name' age' pl' =
  case nonEmpty name' of
   Nothing -> Left "Empty name value."
   -- if name is empty, it will tell us that
   -- if it's not empty, it returns Just name and goes on to
   -- the next check
   Just named ->
     case nonNegative age' of
      Nothing -> Left "Negative age."
      -- if a negative number, we get Nothing; otherwise, go on
      Just aged ->
        case nonEmpty pl' of
          Nothing -> Left "Empty prog lang."
          -- and again check for empty strings
          Just lang ->
              plCheck (Person named aged lang)



Because the `m a` value has to be passed to the `(a -> m b)` function, if there's ever a `Nothing` value, there is no `a` value to get passed to the function. `Monad` is a kind of fancy function composition, so when one function application results in a value that we can't apply a function to, the whole thing just ends. Sometimes, such as when the monad in question is `IO`, what we're really talking about is chaining together a sequence of *actions*; with pure functions, it often doesn't matter what order we execute them in, but with `IO` actions it often does. Monads are structured to respect that sequencing. But the neat thing is that underneath it all, we're still talking about nested lambdas -- but that's probably going to get saved for a later post.

## Applicative

![](/images/vaders-tie-fighter.jpg)




We can also rewrite that with the monadic operator, `(>>=)`, since that's what `do` syntax desugars to:

```haskell
mkPer :: String -> Int -> String -> Maybe Person
mkPer name' age' pl' = 
  Person <$> (nonEmpty name') 
         <*> (nonNegative age') 
         <*> (nonEmpty pl') 
  >>= plCheck
```
But that looks a little funny 




